diff -u -r -N PageFault/kern/console.c Shell/kern/console.c
--- PageFault/kern/console.c	1970-01-01 01:00:00.000000000 +0100
+++ Shell/kern/console.c	2008-12-16 14:06:38.000000000 +0100
@@ -0,0 +1,48 @@
+#include "screen.h"
+#include "console.h"
+#include "process.h"
+
+/* 
+ * Pour copier un caractere dans le buffer utilisateur, il faut etre dans le
+ * contexte du processus en question ! 
+ */
+void putc_console(char c)
+{
+	struct process *p;
+
+	/* En l'absence de console, on ecrit directement dans la memoire video */
+	if (!current_term || !(p = current_term->pread) || p->state<1) {
+		putcar(c);
+		return;
+	}
+
+	if (p->console->mode == 0) {	/* Not buffered mode */
+		putcar(c);
+		p->console->inb[0] = c;
+		p->console->term->pread = 0;
+		p->console->inlock = 0;
+	} else {			/* Buffered modes */
+		if (c == 8) {		/* backspace */
+			if (p->console->keypos) {
+				p->console->inb[p->console->keypos--] = 0;
+				if (p->console->mode == 1)
+					putcar(c);
+			}
+		}
+		else if (c == 10) {	/* newline */
+			if (p->console->mode == 1)
+				putcar(c);
+			p->console->inb[p->console->keypos++] = c;
+			p->console->inb[p->console->keypos] = 0; 
+			p->console->term->pread = 0;
+			p->console->inlock = 0;
+			p->console->keypos = 0;
+		}
+		else {
+			if (p->console->mode == 1)
+				putcar(c);
+			p->console->inb[p->console->keypos++] = c; 
+		}
+
+	} 
+}
diff -u -r -N PageFault/kern/console.h Shell/kern/console.h
--- PageFault/kern/console.h	1970-01-01 01:00:00.000000000 +0100
+++ Shell/kern/console.h	2008-12-10 17:45:37.000000000 +0100
@@ -0,0 +1,22 @@
+
+#define INBUFSIZE 4096
+
+#ifndef __CONS__
+#define __CONS__
+struct terminal {
+	struct process *pread;	/* pointe sur le processus qui lit a partir de la console */
+	struct process *pwrite;	/* pointe sur le processus qui ecrit sur la console */
+};
+
+struct vconsole {
+	struct terminal *term;	/* terminal */
+	char inb[INBUFSIZE];		/* input buffer */
+	int inlock;		/* wait for input (1) */
+	int keypos;		/* read pointer */
+	int mode;		/* not buffered (0), buffered (1), fully buffered (2) */
+};
+#endif
+
+struct terminal *current_term;
+
+void putc_console(char);
diff -u -r -N PageFault/kern/elf.c Shell/kern/elf.c
--- PageFault/kern/elf.c	2008-12-08 16:26:55.000000000 +0100
+++ Shell/kern/elf.c	2008-12-09 10:15:01.000000000 +0100
@@ -20,7 +20,7 @@
 		return 0;
 }
 
-u32 load_elf(char *file)
+u32 load_elf(char *file, struct process *proc)
 {
 	char *p;
 	u32 v_begin, v_end;
@@ -52,6 +52,19 @@
 				return 0;
 			}
 
+
+			/* Description de la zone exec + rodata */
+			if (p_entry->p_flags == PF_X + PF_R) {	
+				proc->b_exec = (char*) v_begin;
+				proc->e_exec = (char*) v_end;
+			}
+
+			/* Description de la zone bss */
+			if (p_entry->p_flags == PF_W + PF_R) {	
+				proc->b_bss = (char*) v_begin;
+				proc->e_bss = (char*) v_end;
+			}
+
 			memcpy((char *) v_begin, (char *) (file + p_entry->p_offset), p_entry->p_filesz);
 
 			if (p_entry->p_memsz > p_entry->p_filesz)
diff -u -r -N PageFault/kern/elf.h Shell/kern/elf.h
--- PageFault/kern/elf.h	2008-12-08 16:27:36.000000000 +0100
+++ Shell/kern/elf.h	2008-12-09 10:15:01.000000000 +0100
@@ -1,6 +1,7 @@
 #include "types.h"
 #include "list.h"
 #include "mm.h"
+#include "process.h"
 
 /*
  * ELF HEADER
@@ -82,6 +83,12 @@
 #define	PT_LOPROC  0x70000000
 #define	PT_HIPROC  0x7fffffff
 
+/* p_flags */
+#define PF_X	0x1
+#define PF_W	0x2
+#define PF_R	0x4
+
+
 int is_elf(char *);
-u32 load_elf(char *);
+u32 load_elf(char *, struct process *);
 
diff -u -r -N PageFault/kern/interrupt.c Shell/kern/interrupt.c
--- PageFault/kern/interrupt.c	2008-12-08 16:47:44.000000000 +0100
+++ Shell/kern/interrupt.c	2008-12-09 10:22:51.000000000 +0100
@@ -9,6 +9,7 @@
 #include "mm.h"
 #include "kmalloc.h"
 #include "syscalls.h"
+#include "console.h"
 
 void isr_default_int(void)
 {
@@ -35,7 +36,7 @@
     		mov %%eax, %2"
 		: "=m"(eip), "=m"(faulting_addr), "=m"(code));
 
-	printk("DEBUG: isr_PF_exc(): #PF on eip: %p. cr2: %p code: %p\n", eip, faulting_addr, code);
+	//// printk("DEBUG: isr_PF_exc(): #PF on eip: %p. cr2: %p code: %p\n", eip, faulting_addr, code);
 
 	if (faulting_addr >= USER_OFFSET && faulting_addr < USER_STACK) {
 		pg = (struct page *) kmalloc(sizeof(struct page));
@@ -58,7 +59,6 @@
 	if (tic % 100 == 0) {
 		sec++;
 		tic = 0;
-		//// putcar('.');
 	}
 	schedule();
 }
@@ -93,7 +93,7 @@
 			alt_enable = 1;
 			break;
 		default:
-			putcar(kbdmap
+			putc_console(kbdmap
 			       [i * 4 + (lshift_enable || rshift_enable)]);
 		}
 	} else {		/* touche relachee */
diff -u -r -N PageFault/kern/kernel.c Shell/kern/kernel.c
--- PageFault/kern/kernel.c	2008-12-08 16:49:41.000000000 +0100
+++ Shell/kern/kernel.c	2008-12-17 14:39:02.000000000 +0100
@@ -1,4 +1,5 @@
 #include "types.h"
+#include "list.h"
 #include "lib.h"
 #include "gdt.h"
 #include "screen.h"
@@ -52,11 +53,13 @@
 	init_mm(mbi->high_mem);
 	ok_msg();
 
+	hide_hw_cursor();
+
 	{
-		int i;
 		struct partition *p1;
 		struct disk *hd;
 		struct file *fp;
+		struct terminal tty1;
 
 		/* 
 		 * Lecture des informations relatives a la premiere partition
@@ -79,6 +82,10 @@
 		f_root = init_root(hd);
 		ok_msg();
 
+		/* Initialise le terminal */
+		tty1.pread = tty1.pwrite = 0;
+		current_term = &tty1;
+
 		/* 
 		 * Initialise le thread kernel 
 		 */
@@ -86,28 +93,26 @@
 		current->pid = 0;
 		current->state = 1;
 		current->regs.cr3 = (u32) pd0;
+		current->console = 0;
 		current->pwd = f_root;
 
-		/* Lancement de taches */
-		fp = path_to_file("/tmp/task1");
+		/* Lancement du shell */
+		fp = path_to_file("/bin/sh");
 		fp->inode = ext2_read_inode(hd, fp->inum);
-		load_task(hd, fp->inode);
-
-		fp = path_to_file("/tmp/task2");
-		fp->inode = ext2_read_inode(hd, fp->inum);
-		load_task(hd, fp->inode);
+		load_task(hd, fp->inode, 0, 0);
 
 		kattr = 0x47;
 		printk("Interrupts are enable. System is ready !\n\n");
 		kattr = 0x07;
-		hide_cursor();
 
 		sti;
 
 		while (1) {
-			printk("kernel: %d process, %dB used by kmalloc\n", n_proc, kmalloc_used);
-
-			for (i = 0; i < 10000000; i++);
+			if (n_proc == 0) {
+				cli;
+				load_task(hd, fp->inode, 0, 0);
+				sti;
+			}
 		}
 	}
 
diff -u -r -N PageFault/kern/Makefile Shell/kern/Makefile
--- PageFault/kern/Makefile	2008-12-08 17:04:41.000000000 +0100
+++ Shell/kern/Makefile	2008-12-11 17:11:54.000000000 +0100
@@ -1,9 +1,16 @@
-OBJ=kernel
+
 CC=gcc -g -Wall -fno-builtin -I.
 
-all: $(OBJ) 
+SRC= $(wildcard *.c)
+OBJ= $(SRC:.c=.o)
+
+SRC_SYSCALLS= $(wildcard syscalls/*.c)
+OBJ_SYSCALLS= $(SRC_SYSCALLS:.c=.o)
+
+
+all: kernel
 
-kernel: boot.o kernel.o screen.o lib.o gdt.o idt.o interrupt.o int.o pic.o syscalls.o mm.o process.o printk.o schedule.o sched.o kmalloc.o disk.o ext2.o elf.o file.o syscalls/sys_exit.o
+kernel: boot.o sched.o int.o $(OBJ) $(OBJ_SYSCALLS)
 	ld -Ttext=100000 --entry=_start $^ -o $@
 
 boot.o: boot.asm
@@ -19,7 +26,7 @@
 	$(CC) -c $^
 
 clean:
-	rm -f $(OBJ) *.o syscalls/*.o
+	rm -f kernel *.o syscalls/*.o
 
 indent: 
-	indent -kr -i8 -ts8 *.c *.h
+	indent -kr -i8 -ts8 *.c *.h */*.c */*.h
diff -u -r -N PageFault/kern/process.c Shell/kern/process.c
--- PageFault/kern/process.c	2008-12-09 10:35:54.000000000 +0100
+++ Shell/kern/process.c	2008-12-17 19:00:06.000000000 +0100
@@ -15,16 +15,19 @@
 /*
  * Charge une tache en memoire
  */
-int load_task(struct disk *hd, struct ext2_inode *inode)
+int load_task(struct disk *hd, struct ext2_inode *inode, int argc, char **argv)
 {
 	struct page *kstack;
 	struct process *previous;
+	struct vconsole *console;
 
+	char **param, **uparam;
 	char *file;
 	u32 stackp;
-	u32 e_entry;
+	u32 e_entry; 
 
 	int pid;
+	int i;
 
 	/* 
 	 * Calcul du pid du nouveau processus. Assume qu'on n'atteindra jamais
@@ -41,6 +44,16 @@
 	n_proc++;
 	p_list[pid].pid = pid;
 
+	/* On copie les arguments a passer au programme */
+	if (argc) {
+		param = (char**) kmalloc(sizeof(char*) * (argc+1));
+		for (i=0 ; i<argc ; i++) {
+			param[i] = (char*) kmalloc(strlen(argv[i]) + 1);
+			strcpy(param[i], argv[i]);
+		}
+		param[i] = 0;
+	}
+
 	/* Cree un repertoire de pages */
 	p_list[pid].pd = pd_create();
 
@@ -63,9 +76,12 @@
 	 * ressources precedement allouees.
 	 */
 	file = ext2_read_file(hd, inode);
-	e_entry = (u32) load_elf(file);
+	e_entry = (u32) load_elf(file, &p_list[pid]);
 	kfree(file);
 	if (e_entry == 0) {	/* echec */
+		for (i=0 ; i<argc ; i++) 
+			kfree(param[i]);
+		kfree(param);
 		current = previous;
 		asm("mov %0, %%eax ;mov %%eax, %%cr3"::"m" (current->regs.cr3));
 		pd_destroy(p_list[pid].pd);
@@ -78,9 +94,52 @@
 	 */
 	stackp = USER_STACK - 16;
 
+	/* Copie des parametres sur la pile utilisateur */
+	if (argc) {
+		uparam = (char**) kmalloc(sizeof(char*) * argc);
+
+		for (i=0 ; i<argc ; i++) {
+			stackp -= (strlen(param[i]) + 1);
+			strcpy((char*) stackp, param[i]);
+			uparam[i] = (char*) stackp;
+		}
+
+		stackp &= 0xFFFFFFF0;		/* alignement */
+
+		/* Creation des arguments de main() : argc, argv[]... */
+		stackp -= sizeof(char*);
+		*((char**) stackp) = 0;
+
+		for (i=argc-1 ; i>=0 ; i--) {		/* argv[0] a argv[n] */
+			stackp -= sizeof(char*);
+			*((char**) stackp) = uparam[i]; 
+		}
+
+		stackp -= sizeof(char*);	/* argv */
+		*((char**) stackp) = (char*) (stackp + 4); 
+
+		stackp -= sizeof(char*);	/* argc */
+		*((int*) stackp) = argc; 
+
+		stackp -= sizeof(char*);
+
+		for (i=0 ; i<argc ; i++) 
+			kfree(param[i]);
+
+		kfree(param);
+		kfree(uparam);
+	}
+
 	/* Cree la pile noyau */
 	kstack = get_page_from_heap();
 
+	/* On associe une console au processus */
+	console = (struct vconsole *) kmalloc(sizeof(struct vconsole));
+	console->term = current_term;
+	console->inlock = 0;
+	console->keypos = 0;
+	console->mode = 1;	/* buffered mode */
+
 	/* Initialise le reste des registres et des attributs */
 	p_list[pid].regs.ss = 0x33;
 	p_list[pid].regs.esp = stackp;
@@ -108,10 +167,22 @@
 	/* p_list[pid].pd; */
 	/* p_list[pid].pglist; */
 
+	/* 
+	 * Attributs deja initialises par load_elf():
+	 *   p_list[pid].b_exec;
+	 *   p_list[pid].e_exec;
+	 *   p_list[pid].b_bss;
+	 *   p_list[pid].e_bss;
+	 */
+	p_list[pid].b_heap = (char*) ((u32) p_list[pid].e_bss & 0xFFFFF000) + PAGESIZE;
+	p_list[pid].e_heap = p_list[pid].b_heap;
+
 	p_list[pid].pwd = previous->pwd;
 
 	p_list[pid].fd = 0;	/* Aucun fichier ouvert */
 
+	p_list[pid].console = console;
+
 	p_list[pid].state = 1;
 
 	current = previous;
diff -u -r -N PageFault/kern/process.h Shell/kern/process.h
--- PageFault/kern/process.h	2008-12-08 16:09:56.000000000 +0100
+++ Shell/kern/process.h	2008-12-17 14:36:10.000000000 +0100
@@ -1,6 +1,7 @@
 #include "types.h"
 #include "list.h"
 #include "ext2.h"
+#include "console.h"
 
 #define KERNELMODE	0
 #define USERMODE	1
@@ -32,13 +33,22 @@
 	 */
 
 	/* NOTE: redondance entre regs.cr3 et pd->base->p_addr */
-	struct page_directory *pd;
+	struct page_directory *pd;	
 
 	struct list_head pglist;	/* Pages utilisees par le processus (exec, data, stack) */
 
+	char *b_exec;
+	char *e_exec;
+	char *b_bss;
+	char *e_bss;
+	char *b_heap;
+	char *e_heap;			/* Pointe sur le sommet du "heap" */
+
 	struct file *pwd;		/* Pointe sur le repertoire courant */
 	struct open_file *fd;		/* Liste chainee des fichiers ouverts */
 
+	struct vconsole *console;	/* Console */
+
 	int state;		/* 0 not used, 1 ready/running, 2 sleep */
 
 } __attribute__ ((packed));
@@ -59,4 +69,5 @@
 
 #endif
 
-int load_task(struct disk *, struct ext2_inode *);
+int load_task(struct disk *, struct ext2_inode *, int, char **);
+
diff -u -r -N PageFault/kern/screen.c Shell/kern/screen.c
--- PageFault/kern/screen.c	2008-12-08 15:54:49.000000000 +0100
+++ Shell/kern/screen.c	2008-12-09 10:15:01.000000000 +0100
@@ -30,15 +30,22 @@
 {
 	unsigned char *video;
 
+	hide_cursor();
+	video = (unsigned char *) (RAMSCREEN + 2 * kX + 160 * kY);
+
 	if (c == 10) {		/* CR-NL */
 		kX = 0;
 		kY++;
+	} else if (c == 8) {	/* BS */
+		if (kX) {
+			*(video + 1) = 0x0;
+			kX--;
+		}
 	} else if (c == 9) {	/* TAB */
 		kX = kX + 8 - (kX % 8);
 	} else if (c == 13) {	/* CR */
 		kX = 0;
 	} else {		/* autres caracteres */
-		video = (unsigned char *) (RAMSCREEN + 2 * kX + 160 * kY);
 		*video = c;
 		*(video + 1) = kattr;
 
@@ -51,9 +58,11 @@
 
 	if (kY > 24)
 		scrollup(kY - 24);
+
+	show_cursor();
 }
 
-void move_cursor(u8 x, u8 y)
+void move_hw_cursor(u8 x, u8 y)
 {
 	u16 c_pos;
 
@@ -65,12 +74,28 @@
 	outb(0x3d5, (u8) (c_pos >> 8));
 }
 
-void show_cursor(void)
+void hide_hw_cursor(void)
+{
+	move_hw_cursor(-1, -1);
+}
+
+void show_cursor()
 {
-	move_cursor(kX, kY);
+	unsigned char *video;
+
+	cursorX = kX;
+	cursorY = kY;
+
+	video = (unsigned char *) (RAMSCREEN + 2 * cursorX + 160 * cursorY);
+	*video = cursorC;
+	*(video + 1) = cursorA;
 }
 
 void hide_cursor(void)
 {
-	move_cursor(-1, -1);
+	unsigned char *video;
+
+	video = (unsigned char *) (RAMSCREEN + 2 * cursorX + 160 * cursorY);
+	*(video + 1) = 0x0;
 }
+
diff -u -r -N PageFault/kern/screen.h Shell/kern/screen.h
--- PageFault/kern/screen.h	2008-12-08 15:54:49.000000000 +0100
+++ Shell/kern/screen.h	2008-12-09 10:15:01.000000000 +0100
@@ -11,16 +11,26 @@
 char kY = 8;
 char kattr = 0x07;		/* attributs video des caracteres a afficher */
 
+char cursorX = 0;		/* position du curseur */
+char cursorY = 8;
+char cursorA = 0x40;
+char cursorC = ' ';
+
 #else
 
 extern char kX;
 extern char kY;
 extern char kattr;
+extern char cursorX;
+extern char cursorY;
+extern char cursorA;
+extern char cursorC;
 
 #endif				/* __SCREEN__ */
 
 void scrollup(unsigned int);
 void putcar(uchar);
-void move_cursor(u8, u8);
+void move_hw_cursor(u8, u8);
+void hide_hw_cursor(void);
 void show_cursor(void);
 void hide_cursor(void);
diff -u -r -N PageFault/kern/syscalls/sys_console_read.c Shell/kern/syscalls/sys_console_read.c
--- PageFault/kern/syscalls/sys_console_read.c	1970-01-01 01:00:00.000000000 +0100
+++ Shell/kern/syscalls/sys_console_read.c	2008-12-16 14:07:00.000000000 +0100
@@ -0,0 +1,26 @@
+#include "types.h"
+#include "lib.h"
+#include "process.h"
+#include "console.h"
+
+int sys_console_read(char *u_buf)
+{
+		if (!current->console->term) {
+			printk("DEBUG: sys_console_read(): process without term\n");
+			return -1;
+		}
+
+		/* Bloque si la console est deja utilisee */
+		while (current_term->pread);
+
+		current->console->term->pread = current;
+		current->console->inlock = 1;
+
+		/* Bloque jusqu'a ce que le buffer utilisateur soit rempli */
+		while (current->console->inlock == 1);
+
+		strcpy(u_buf, current->console->inb);
+
+		return strlen(u_buf);
+}
+
diff -u -r -N PageFault/kern/syscalls/sys_exec.c Shell/kern/syscalls/sys_exec.c
--- PageFault/kern/syscalls/sys_exec.c	1970-01-01 01:00:00.000000000 +0100
+++ Shell/kern/syscalls/sys_exec.c	2008-12-17 14:39:51.000000000 +0100
@@ -0,0 +1,32 @@
+#include "types.h"
+#include "list.h"
+#include "io.h"
+#include "lib.h"
+#include "file.h"
+#include "process.h"
+
+int sys_exec(char *path, char **argv)
+{
+	char **ap;
+	int argc, pid;
+	struct file *fp;
+
+	if (!(fp = path_to_file(path))) {
+		printk("DEBUG: sys_exec(): %s: command not found\n", path);
+		return -1;
+	}
+
+	if (!fp->inode)
+		fp->inode = ext2_read_inode(fp->disk, fp->inum);
+
+	ap = argv;
+	argc = 0;
+	while (*ap++) 
+		argc++;
+
+	cli;
+	pid = load_task(fp->disk, fp->inode, argc, argv);
+	sti;
+
+	return pid;
+}
diff -u -r -N PageFault/kern/syscalls/sys_exit.c Shell/kern/syscalls/sys_exit.c
--- PageFault/kern/syscalls/sys_exit.c	2008-12-08 17:02:58.000000000 +0100
+++ Shell/kern/syscalls/sys_exit.c	2008-12-17 14:40:05.000000000 +0100
@@ -17,7 +17,7 @@
 	struct page *pg;
 	struct open_file *fd, *fdn;
 
-	printk("DEBUG: sys_exit(): process[%d] exit\n", current->pid);     /* DEBUG */
+	//// printk("DEBUG: sys_exit(): process[%d] exit\n", current->pid);     /* DEBUG */
 
 	n_proc--;
 	current->state = 0;
@@ -53,6 +53,10 @@
 		fd = fdn;
 	}
 
+	/* Libere la console */
+	kfree(current->console);
+	current->console = 0;
+
 	/* Libere la pile noyau */
 	kss = p_list[0].regs.ss;
 	kesp = p_list[0].regs.esp;
diff -u -r -N PageFault/kern/syscalls/sys_open.c Shell/kern/syscalls/sys_open.c
--- PageFault/kern/syscalls/sys_open.c	1970-01-01 01:00:00.000000000 +0100
+++ Shell/kern/syscalls/sys_open.c	2008-12-09 13:08:46.000000000 +0100
@@ -0,0 +1,65 @@
+#include "types.h"
+#include "list.h"
+#include "lib.h"
+#include "io.h"
+#include "process.h"
+#include "kmalloc.h"
+#include "mm.h"
+#include "schedule.h"
+#include "file.h"
+#include "console.h"
+#include "signal.h"
+#include "syscalls.h"
+
+
+int sys_open(char *path)
+{
+	u32 fd;
+	struct file *fp;
+	struct open_file *of;
+
+	if (!(fp = path_to_file(path))) {
+		//// printk("DEBUG: sys_open(): can't open %s\n", path);
+		return -1;
+	}
+
+	//// printk("DEBUG: sys_open(): process[%d] opening file %s\n", current->pid, fp->name);
+	
+	fp->opened++;
+
+	if (!fp->inode)
+		fp->inode = ext2_read_inode(fp->disk, fp->inum);
+
+	/* Lecture du fichier */
+	fp->mmap = ext2_read_file(fp->disk, fp->inode);
+
+	/* 
+	 * Recherche d'un descripteur libre.
+	 */
+	fd = 0;
+	if (current->fd == 0) {
+		current->fd = (struct open_file *) kmalloc(sizeof(struct open_file));
+		current->fd->file = fp;
+		current->fd->ptr = 0;
+		current->fd->next = 0;
+	} else {
+		of = current->fd;
+		while (of->file && of->next) {
+			of = of->next;
+			fd++;
+		}
+
+		if (of->file == 0) {	/* reutilisation d'un descripteur precedement ouvert */
+			of->file = fp;
+			of->ptr = 0;
+		} else {		/* nouveau descripteur */
+			of->next = (struct open_file *) kmalloc(sizeof(struct open_file));
+			of->next->file = fp;
+			of->next->ptr = 0;
+			of->next->next = 0;
+			fd++;
+		}
+	}
+
+	return fd;
+}
diff -u -r -N PageFault/kern/syscalls/sys_sbrk.c Shell/kern/syscalls/sys_sbrk.c
--- PageFault/kern/syscalls/sys_sbrk.c	1970-01-01 01:00:00.000000000 +0100
+++ Shell/kern/syscalls/sys_sbrk.c	2008-12-10 17:47:17.000000000 +0100
@@ -0,0 +1,10 @@
+#include "process.h"
+
+char* sys_sbrk(int size)
+{
+	char *ret;
+	ret = current->e_heap;
+
+	current->e_heap += size;
+	return ret;
+}
diff -u -r -N PageFault/kern/syscalls.c Shell/kern/syscalls.c
--- PageFault/kern/syscalls.c	2008-12-09 15:14:43.000000000 +0100
+++ Shell/kern/syscalls.c	2008-12-16 14:21:01.000000000 +0100
@@ -8,6 +8,7 @@
 #include "schedule.h"
 #include "file.h"
 #include "syscalls.h"
+#include "console.h"
 
 void do_syscalls(int sys_num)
 {
@@ -33,7 +34,6 @@
 		sti;
 	}
 
-	/* exit */
 	else if (sys_num == 2) {
 		int status;
 
@@ -42,60 +42,12 @@
 		sys_exit(status);
 	}
 
-	/* file open */
 	else if (sys_num == 3) {
 		char *path;
-		u32 fd;
-		struct file *fp;
-		struct open_file *of;
 
+		cli;
 		asm("mov %%ebx, %0": "=m"(path):);
-
-		if (!(fp = path_to_file(path))) {
-			printk("DEBUG: sys_open(): can't open %s\n", path);
-			stack_ptr[14] = -1;
-			return;
-		}
-
-		printk("DEBUG: sys_open(): process[%d] opening file %s\n", current->pid, fp->name);
-		
-		fp->opened++;
-
-		if (!fp->inode)
-			fp->inode = ext2_read_inode(fp->disk, fp->inum);
-
-		/* Lecture du fichier */
-		fp->mmap = ext2_read_file(fp->disk, fp->inode);
-
-		/* 
-		 * Recherche d'un descripteur libre.
-		 */
-		fd = 0;
-		if (current->fd == 0) {
-			current->fd = (struct open_file *) kmalloc(sizeof(struct open_file));
-			current->fd->file = fp;
-			current->fd->ptr = 0;
-			current->fd->next = 0;
-		} else {
-			of = current->fd;
-			while (of->file && of->next) {
-				of = of->next;
-				fd++;
-			}
-
-			if (of->file == 0) {	/* reutilisation d'un descripteur precedement ouvert */
-				of->file = fp;
-				of->ptr = 0;
-			} else {		/* nouveau descripteur */
-				of->next = (struct open_file *) kmalloc(sizeof(struct open_file));
-				of->next->file = fp;
-				of->next->ptr = 0;
-				of->next->next = 0;
-				fd++;
-			}
-		}
-
-		stack_ptr[14] = fd;
+		stack_ptr[14] = sys_open(path);
 	}
 
 	/* file read */
@@ -138,7 +90,7 @@
 
 		asm("mov %%ebx, %0": "=m"(fd):);
 
-		printk("DEBUG: sys_close(): process[%d] closing fd %d\n", current->pid, fd);
+		//// printk("DEBUG: sys_close(): process[%d] closing fd %d\n", current->pid, fd);
 
 		of = current->fd;
 		while (fd) {
@@ -156,7 +108,94 @@
 		of->ptr = 0;
 	}
 
+	else if (sys_num == 6) {
+		char *u_buf;	/* buffer d'entree utilisateur */
+
+		asm("mov %%ebx, %0": "=m"(u_buf):);
+
+		stack_ptr[14] = sys_console_read(u_buf);
+	}
+
+	/* chdir */
+	else if (sys_num == 7) {
+		char *path;
+		struct file *fp;
+
+		asm("mov %%ebx, %0": "=m"(path):);
+
+		if (!(fp = path_to_file(path))) {
+			printk("can't chdir to %s\n", path);
+			return;
+		}
+
+		if (!fp->inode)
+			fp->inode = ext2_read_inode(fp->disk, fp->inum);
+
+		if (!is_directory(fp)) {
+			printk("%s is not a directory\n", path);
+			return;
+		}
+
+		current->pwd = fp;
+		//// printk("DEBUG: sys_chdir() to %s\n", current->pwd->name);
+	}
+
+
+	/* pwd */
+	else if (sys_num == 8) {
+		char *u_buf;
+		int sz;
+		struct file *fp;
+
+		asm("mov %%ebx, %0": "=m"(u_buf):);
+
+		if (current->pwd == f_root) {
+			u_buf[0] = '/';
+			u_buf[1] = 0;
+			return;
+		}
+
+		fp = current->pwd;
+		sz = strlen(fp->name) + 1;
+		while (fp->parent != f_root) {
+			fp = fp->parent;
+			sz += (strlen(fp->name) + 1);
+		}
+
+		fp = current->pwd;
+		u_buf[sz] = 0;
+
+		while (sz > 0) {
+			memcpy(u_buf + sz - strlen(fp->name), fp->name,
+			       strlen(fp->name));
+			sz -= (strlen(fp->name) + 1);
+			u_buf[sz] = '/';
+			fp = fp->parent;
+		}
+
+		//// printk("DEBUG: sys_pwd(): %s\n", current->pwd->name);
+	}
+
+	else if (sys_num == 9) {
+		char *path;
+		char **argv;
+
+		asm("	mov %%ebx, %0	\n \
+			mov %%ecx, %1"
+			: "=m"(path), "=m"(argv) :);
+
+		stack_ptr[14] = sys_exec(path, argv);
+	}
+
 	else if (sys_num == 10) {
+		int  size;
+
+		asm("mov %%ebx, %0": "=m"(size):);
+		stack_ptr[14] = (u32) sys_sbrk(size);
+	}
+
+	/* debug */
+	else if (sys_num == 100) {
 		u32 *pa;
 		asm("mov %%ebp, %0": "=m"(pa):);
 		printk("eax: %p ecx: %p edx: %p ebx: %p\n", pa[12], pa[11], pa[10], pa[9]);
diff -u -r -N PageFault/kern/syscalls.h Shell/kern/syscalls.h
--- PageFault/kern/syscalls.h	2008-12-08 16:39:25.000000000 +0100
+++ Shell/kern/syscalls.h	2008-12-11 17:16:20.000000000 +0100
@@ -1,2 +1,6 @@
 
 void sys_exit(int);
+int sys_open(char*);
+char* sys_sbrk(int);
+int sys_exec(char *, char **);
+int sys_console_read(char*);
